{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"bobbie","text":"Version Status Documentation Tools Compatibility Stats"},{"location":"#what-is-bobbie","title":"What is bobbie?","text":"<p>Named after Roberta Draper (\"Bobbie\") from \"The Expanse,\" <code>bobbie</code> provides a lightweight and easy-to-use way to store and access configuration settings for a Python project.</p>"},{"location":"#why-use-bobbie","title":"Why use bobbie?","text":"<p>There are numerous options for storing configuration settings in Python. So, what makes <code>bobbie</code> different?</p> <ul> <li>Flexible: a <code>Settings</code> instance is easily built from a <code>dict</code>, Python module, or file (env, ini, json, toml, xml, and yaml formats are supported).</li> <li>Lightweight: an efficient codebase ensures a very small memory footprint.</li> <li>Intuitive: a <code>create</code> class method constructs <code>Settings</code> (from any data source).</li> <li>Convenient: unlike <code>configparser</code>, automatic data and type validation is performed when   <code>Settings</code> is created.</li> </ul> <p>The comparison table below shows how <code>bobbie</code> compares to the other major options that store configuration options for Python projects.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#installation","title":"Installation","text":"<p>To install <code>bobbie</code>, use <code>pip</code>:</p> <pre><code>pip install bobbie\n</code></pre>"},{"location":"#create-a-settings-instance","title":"Create a Settings instance","text":"<p><code>bobbie</code> supports several ways to create a <code>Settings</code> instance. You can either: * If the settings are in a file, call a class method specific to the file type (<code>from_yaml</code> in the second example below); * Call a class method for the general type of source data (<code>from_dict</code> or <code>from_file</code>); * Call the <code>create</code> class method and it will automatically figure out the appropriate constructor; or  * If the settings data is in a <code>dict</code>-like object, pass it as the first argument to <code>Settings</code>.</p>"},{"location":"#from-a-dict","title":"From a <code>dict</code>","text":"<pre><code>import bobbie\n\nconfiguration = {\n  'general': {\n    'verbose': False,\n    'seed': 43,\n    'parallelize': False},\n  'files': {\n    'source_format': 'csv',\n    'file_encoding': 'windows-1252',\n    'float_format': '%.4f',\n    'export_results': True}}\n# You can pick a specific constructor method.\nsettings = bobbie.Settings.from_dict(configuration) \n# Or, may use the general `create` method.\nsettings = bobbie.Settings.create(configuration)\n# Or, just send a `dict` to `Settings` itself.\nsettings = bobbie.Settings(configuration)\n</code></pre>"},{"location":"#from-a-file","title":"From a file","text":"<pre><code>import bobbie\n\n# You may use the general `create` method.\nsettings = bobbie.Settings.create('settings_file.yaml')\n# Or, the `from_file` method.\nsettings = bobbie.Settings.from_file('settings_file.yaml')\n# Or, the `from_yaml` method. They all do the same thing.\nsettings = bobbie.Settings.from_yaml('settings_file.yaml')\n# Or, \n</code></pre> <p>If the file is a Python module, it must contain a variable named <code>settings</code> in the module namespace (unless you change the global setting for the variable name).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar projects","text":"<p>There are a lot of great packages for storing project settings. The table below shows the features of the leading libraries.</p>"},{"location":"#feature-comparison-of-python-configuration-libraries","title":"Feature Comparison of Python Configuration Libraries","text":"Library Typing Secrets dict env ini json py toml yaml <code>bobbie</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>configParser</code> \u2705 <code>dynaconf</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>Parser-it</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>python-decouple</code> \u2705 \u2705 \u2705 \u2705 <code>pyconfig</code> \u2705 <code>pydantic-settings</code> \u2705 \u2705 <p>As you can see, <code>bobbie</code> lacks a method for storing passwords, encryption keys, and other secrets. That is because it is focused on internal Python projects and the goal of keeping its resource usage as low as possible. So, if you need secrets stored in your project settings, there are several good options linked above that you should explore.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>I would like to thank the University of Kansas School of Law for tolerating and supporting this law professor's coding efforts, an endeavor which is well outside the typical scholarly activities in the discipline.</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#017","title":"0.1.7","text":"<ul> <li>Fixed GitHub actions bug with <code>pdm</code> and <code>ruff</code></li> <li>Fixed typo in readme</li> </ul>"},{"location":"changelog/#016","title":"0.1.6","text":"<ul> <li>Added documentation and readme</li> <li>Added more tests</li> <li>Added .env support</li> <li>Changed required Python version to 3.11 or later</li> </ul>"},{"location":"changelog/#015","title":"0.1.5","text":"<ul> <li>Changelogs not stored before the transitition to the <code>snickerdoodle</code> template</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build bobbie. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>bunches</code> Drop-in replacements for Python collections <code>&gt;= 0.1.3</code> <code>0.1.3</code> Apache Software License 2.0 <code>pyyaml</code> YAML parser and emitter for Python <code>6.0.2</code> MIT <code>wonka</code> Flexible, accessible, extensible Python factories <code>&gt;= 0.1.4</code> <code>0.1.5</code> Apache Software License 2.0"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>~=2.10</code> <code>2.17.0</code> BSD-3-Clause <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2025.1.31</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.4.1</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.8</code> BSD License <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>7.6.12</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.9</code> PSF-2.0 <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=2.1</code> <code>2.1.1</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.17.0</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.12</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.44</code> BSD-3-Clause <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.49</code> <code>1.5.7</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.6.7</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.10</code> BSD License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.5</code> BSD License <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&gt;=3.3.3</code> <code>3.7</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>0.4.0</code> MIT License <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>1.10.0</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>3.0.2</code> BSD License <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>1.6.1</code> BSD License <code>mkdocs-autorefs</code> Automatically link across pages in MkDocs. <code>&gt;=1.2</code> <code>1.3.1</code> ISC <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>1.1.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>0.5.0</code> MIT License <code>mkdocs-get-deps</code> MkDocs extension that lists all dependencies according to a mkdocs.yml file <code>&gt;=0.2.0</code> <code>0.2.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of GitHub or GitLab committers and other useful GIT info such as last modified date <code>2.5.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>0.6.1</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>9.6.5</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>0.8.0</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]</code> <code>0.28.1</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.16.1</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.9.1</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>24.2</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.7</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=2.2.0</code> <code>4.3.6</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2,&gt;=1.5</code> <code>1.5.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>4.1.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.19.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.14.3</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>8.3.4</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>6.0.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>3.16.0</code> MIT License <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>3.6.1</code> MIT License <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.2</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2024.11.6</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.32.3</code> Apache-2.0 <code>ruff</code> An extremely fast Python linter and code formatter, written in Rust. <code>0.9.7</code> MIT <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.2</code> BSD-3-Clause <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>0.10.2</code> MIT <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.3.0</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.29.2</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>6.0.0</code> Apache-2.0"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2023, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> bobbie<ul> <li> base</li> <li> options</li> <li> utilities</li> </ul> </li> </ul>"},{"location":"reference/bobbie/","title":"Index","text":"<p>Flexible, easy python project configuration</p>"},{"location":"reference/bobbie/#bobbie.Settings","title":"<code>Settings(contents=dict(), name=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sourcerer</code>, <code>Dictionary</code></p> <p>Loads and stores configuration settings.</p> <p>This class has an interface of an ordinary <code>dict</code>. It also adds class and instance methods that are helpful for project settings, including loading directly from numberous file types, easy injection of settings data as attributes into objects, and smart automatic type conversion from files when appropriate (depending on whether the file type supports typing).</p> <p>Currently, supported file extensions are:</p> <ul> <li><code>env</code>, <code>ini</code>, <code>json</code>, <code>py</code>, <code>toml</code>, <code>xml</code>, <code>yaml</code>, and <code>yml</code>.</li> </ul> <p>The best way to create a <code>Settings</code> instance is to call <code>Settings.create</code> and pass as the first argument a:     1) <code>pathlib</code> or <code>str</code> path to a compatible file (including a Python         module);     2) a <code>dict</code> or <code>dict</code>-like object;                                     or     3) a sequence of <code>pathlib</code> paths, <code>str</code> paths, or mappings (mixed types        in the sequence are supported).</p> <p>Any other arguments that you want passed to <code>Settings</code> (such as <code>name</code>) should be passed to the <code>parameters</code> argument. Any additional kwargs that you pass will be relayed to the constructor used by <code>bobbie</code>. For example, in Python 3.11, the builtin <code>tomllib</code> library to parse <code>toml</code> files. If you want to change the float parser to <code>decimal.Decimal</code> when loading settings from a \".toml\" file and name your <code>Settings</code> instance \"Project Settings\", you should do this:</p> <pre><code>Settings.create(\n    'configuration.toml',\n    parameters = {'name': 'Project Settings'},\n    {'parse_float': decimal.Decimal})\n</code></pre> <p>You may also instance <code>Settings</code> directly, like a normal class. However, doing so precludes the ability to relay additional keyword arguments to the constructor used by <code>bobbie</code> (<code>parse_float</code> in the above example).</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>GenericDict</code> <p>configuration options. Defaults to an empty <code>dict</code>.</p> <code>dict()</code> <code>default_factory</code> <p>default value to return or default callable to use to create the default value.</p> required <code>name</code> <code>str | None</code> <p>the <code>str</code> name of <code>Settings</code>. The top-level of a <code>Settings</code> need not have any name, but may include one for use by custom parsers. Defaults to <code>None</code>.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>defaults</code> <p>default options that should be used when a user does not provide the corresponding options in their configuration settings, but are otherwise necessary for the project. These are automatically added as the last mapping in <code>contents</code> so that all other loaded and stored options are checked first. Defaults to an empty <code>dict</code>.</p> <code>sources</code> <code>MutableMapping[type[Any], str]</code> <p><code>dict</code> with keys that are types and values are substrings of the names of methods to call when the key type is passed to the <code>create</code> method. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/bobbie/#bobbie.Settings.sources","title":"<code>sources = {pathlib.Path: 'file', str: 'file', MutableMapping: 'dict'}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/bobbie/#bobbie.Settings._get_loader","title":"<code>_get_loader(path)</code>  <code>classmethod</code>","text":"<p>get_loader _summary</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[str, MethodType]</code> <p>description</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef _get_loader(cls, path: pathlib.Path) -&gt; tuple[str, MethodType]:\n    \"\"\"_get_loader _summary_\n\n    Args:\n        path: _description_\n\n    Returns:\n        _description_\n    \"\"\"\n    if path.is_file():\n        extension = path.suffix[1:]\n        file_type = options._FILE_EXTENSIONS[extension]\n        loader = getattr(cls, options._LOAD_METHOD(file_type))\n        return file_type, loader\n    else:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings._infer_types","title":"<code>_infer_types(contents)</code>  <code>classmethod</code>","text":"<p>Converts stored values to appropriate datatypes.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>GenericDict</code> <p>a <code>dict</code> to reparse.</p> required <p>Returns:</p> Name Type Description <code>GenericDict</code> <code>GenericDict</code> <p>with the nested values converted to the appropriate datatypes.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef _infer_types(cls, contents: GenericDict) -&gt; GenericDict:\n    \"\"\"Converts stored values to appropriate datatypes.\n\n    Args:\n        contents: a `dict` to reparse.\n\n    Returns:\n        GenericDict: with the nested values converted to\n            the appropriate datatypes.\n\n    \"\"\"\n    new_contents = {}\n    for key, value in contents.items():\n        if isinstance(value, MutableMapping):\n            inner_bundle = {\n                inner_key: options._TYPER(inner_value)\n                for inner_key, inner_value in value.items()}\n            new_contents[key] = inner_bundle\n        else:\n            new_contents[key] = options._TYPER(value)\n    return new_contents\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.add","title":"<code>add(key, value)</code>","text":"<p>Adds <code>key</code> and <code>value</code> to <code>contents</code>.</p> <p>If <code>key</code> is already a key in <code>contents</code>, the contents associated with that key are updated. If <code>key</code> doesn't exist, a new key/value pair is added to <code>contents</code>. Stored <code>dict</code>-like objects in <code>value</code> are automatically converted to <code>Settings</code> objects based on the global recursive configuration option.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>name of key to store <code>value</code>.</p> required <code>value</code> <code>GenericDict</code> <p>values to be stored.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>key</code> isn't hashable.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def add(self, key: Hashable, value: GenericDict) -&gt; None:\n    \"\"\"Adds `key` and `value` to `contents`.\n\n    If `key` is already a key in `contents`, the contents associated with\n    that key are updated. If `key` doesn't exist, a new key/value pair is\n    added to `contents`. Stored `dict`-like objects in `value` are\n    automatically converted to `Settings` objects based on the global\n    recursive configuration option.\n\n    Args:\n        key: name of key to store `value`.\n        value: values to be stored.\n\n    Raises:\n        TypeError: if `key` isn't hashable.\n\n    \"\"\"\n    try:\n        self[key].update(value)\n    except KeyError:\n        try:\n            self[key] = value\n        except TypeError as error:\n            message = 'The key must be hashable'\n            raise TypeError(message) from error\n    return\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.create","title":"<code>create(source, /, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Calls appropriate class method to create an instance.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>path to a file or <code>dict</code> with data to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>source</code> is not a <code>str</code>, <code>pathlib.Path</code>, or <code>dict</code>- like object.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@functools.singledispatchmethod\n@classmethod\ndef create(\n    cls,\n    source: Any, /,\n    parameters: GenericDict | None = None,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Calls appropriate class method to create an instance.\n\n    Args:\n        source: path to a file or `dict` with data to store in a `Settings`\n            instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        TypeError: if `source` is not a `str`, `pathlib.Path`, or `dict`-\n            like object.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    message = (\n        'The first positional argument must be a str, Path, or mapping')\n    raise TypeError(message)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.delete","title":"<code>delete(key, return_error=options._ALWAYS_RETURN_ERROR)</code>","text":"<p>Deletes <code>item</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key in <code>contents</code> to delete the key/value pair.</p> required <code>return_error</code> <code>bool</code> <p>returns error if <code>key</code> is missing. Defaults to the global setting stored in options._ALWAYS_RETURN_ERROR.</p> <code>_ALWAYS_RETURN_ERROR</code> Source code in <code>src/bobbie/base.py</code> <pre><code>def delete(\n    self,\n    key: Hashable,\n    return_error: bool = options._ALWAYS_RETURN_ERROR) -&gt; None:\n    \"\"\"Deletes `item` in `contents`.\n\n    Args:\n        key: key in `contents` to delete the key/value pair.\n        return_error: returns error if `key` is missing. Defaults to the\n            global setting stored in options._ALWAYS_RETURN_ERROR.\n\n    \"\"\"\n    try:\n        del self.contents[key]\n    except KeyError as error:\n        if return_error:\n            message = f'{key} is not found in the settings'\n            raise KeyError(message) from error\n    except TypeError as error:\n        message = 'The key must be hashable'\n        raise TypeError(message) from error\n    return\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_dict","title":"<code>from_dict(source, /, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Settings</code> instance from a <code>dict</code>-like object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>GenericDict</code> <p><code>dict</code>-like object with settings to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>any additional keyword arguments are ignored by this constructer method. They are only accepted to ensure compatibility with dispatching from the <code>create</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@create.register(MutableMapping)\n@classmethod\ndef from_dict(\n    cls,\n    source: GenericDict, /,\n    parameters: GenericDict | None = None,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a `Settings` instance from a `dict`-like object.\n\n    Args:\n        source: `dict`-like object with settings to store in a `Settings`\n            instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: any additional keyword arguments are ignored by this\n            constructer method. They are only accepted to ensure\n            compatibility with dispatching from the `create` method.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    parameters = parameters or {}\n    return cls(source, **parameters)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_env","title":"<code>from_env(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to an <code>ini</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_env(cls,source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to an `ini` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import dotenv\n    try:\n        contents = dotenv.dotenv_values(source, **kwargs)\n    except (KeyError, FileNotFoundError) as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['env']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_file","title":"<code>from_file(source, /, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Settings</code> instance from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>path to file with data to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as file encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <code>TypeError</code> <p>if no constructor method is found for the passed file type.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@create.register(str | pathlib.Path)\n@classmethod\ndef from_file(\n    cls,\n    source: str | pathlib.Path, /,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a `Settings` instance from a file path.\n\n    Args:\n        source: path to file with data to store in a `Settings` instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as file encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n        TypeError: if no constructor method is found for the passed file\n            type.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    file_type, loader = cls._get_loader(path)\n    try:\n        return cls(loader(path, **kwargs))\n    except AttributeError as error:\n        message = f'Loading from {file_type} file is not supported'\n        raise TypeError(message) from error\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_ini","title":"<code>from_ini(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to an <code>ini</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_ini(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to an `ini` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import configparser\n    try:\n        contents = configparser.ConfigParser(**kwargs)\n        contents.optionxform = lambda option: option\n        contents.read(path)\n    except (KeyError, FileNotFoundError) as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['ini']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_json","title":"<code>from_json(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>json</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_json(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `json` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import json\n    try:\n        with open(pathlib.Path(path)) as settings_file:\n            contents = json.load(settings_file, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['json']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_module","title":"<code>from_module(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a Python module.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_module(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a Python module.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    try:\n        specer = importlib.util.spec_from_file_location\n        import_path = specer(path.name, path, **kwargs)\n        import_module = importlib.util.module_from_spec(import_path)\n        import_path.loader.exec_module(import_module)\n        contents = getattr(import_module, options._MODULE_SETTINGS_ATTRIBUTE)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['module']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_toml","title":"<code>from_toml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>toml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_toml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `toml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import tomllib\n    loader = tomllib.load\n    try:\n        contents = loader(path, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['toml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_xml","title":"<code>from_xml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>toml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_xml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `toml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import xmltodict\n    try:\n        with open(path) as settings_file:\n            contents = xmltodict.parse(settings_file.read(), **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['xml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.from_yaml","title":"<code>from_yaml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>yaml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_yaml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `yaml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import yaml\n    try:\n        with open(path) as config:\n            contents = yaml.safe_load(config, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['yaml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the <code>fromkeys</code> class method from a python <code>dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>GenericList</code> <p>items to be keys in a new mapping.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new mapping.</p> required <code>kwargs</code> <code>Any</code> <p>additional arguments to pass to the <code>dict.fromkeys</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GenericDict</code> <p>An instance formed from <code>keys</code> and <code>value</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef fromkeys(\n    cls,\n    keys: GenericList,\n    value: Any,\n    **kwargs: Any) -&gt; GenericDict:\n    \"\"\"Emulates the `fromkeys` class method from a python `dict`.\n\n    Args:\n        keys: items to be keys in a new mapping.\n        value: the value to use for all values in a new mapping.\n        kwargs: additional arguments to pass to the `dict.fromkeys` method.\n\n    Returns:\n        An instance formed from `keys` and `value`.\n\n    \"\"\"\n    return cls(dict.fromkeys(keys, value), **kwargs)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns value in <code>contents</code> or default options.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key for value in <code>contents</code>.</p> required <code>default</code> <code>Any | None</code> <p>default value to return if <code>key</code> is not found in <code>contents</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>key</code> is not in <code>contents</code> and <code>default</code> and the <code>default_factory</code> attribute are both <code>None</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Value matching key in <code>contents</code> or a default value.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def get(self, key: Hashable, default: Any | None = None) -&gt; Any:\n    \"\"\"Returns value in `contents` or default options.\n\n    Args:\n        key: key for value in `contents`.\n        default: default value to return if `key` is not found in\n            `contents`.\n\n    Raises:\n        KeyError: if `key` is not in `contents` and `default` and the\n            `default_factory` attribute are both `None`.\n\n    Returns:\n        Value matching key in `contents` or a default value.\n\n    \"\"\"\n    try:\n        return self[key]\n    except (KeyError, TypeError) as error:\n        if default is not None:\n            return default\n        if self.default_factory is None:\n            raise KeyError(f'{key} is not in the Settings') from error\n        try:\n            return self.default_factory()\n        except TypeError:\n            return self.default_factory\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.inject","title":"<code>inject(instance, sections=None, overwrite=None)</code>","text":"<p>Injects appropriate items into <code>instance</code> from <code>contents</code>.</p> <p>By default, if <code>instance</code> has a <code>name</code> attribute, this method will add any settings in a section matching that <code>name</code> to <code>instance</code> as attributes.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>class instance to be modified.</p> required <code>sections</code> <code>Sequence[str] | str | None</code> <p>other section(s) in <code>contents</code> to add to <code>instance</code>. Defaults to None (which will result in all sections being injected).</p> <code>None</code> <code>overwrite</code> <code>bool | None</code> <p>whether to overwrite a local attribute in <code>instance</code> if there are existing values stored in that attribute. Defaults to None (which will result in the default value in <code>_OVERWRITE_ATTRIBUTES</code> will be used).</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Instance with modifications made.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def inject(\n    self,\n    instance: object,\n    sections: Sequence[str] | str | None = None,\n    overwrite: bool | None = None) -&gt; object:\n    \"\"\"Injects appropriate items into `instance` from `contents`.\n\n    By default, if `instance` has a `name` attribute, this method will add\n    any settings in a section matching that `name` to `instance` as\n    attributes.\n\n    Args:\n        instance: class instance to be modified.\n        sections: other section(s) in `contents` to add to `instance`.\n            Defaults to None (which will result in all sections being\n            injected).\n        overwrite: whether to overwrite a local attribute in `instance` if\n            there are existing values stored in that attribute. Defaults to\n            None (which will result in the default value in\n            `_OVERWRITE_ATTRIBUTES` will be used).\n\n    Returns:\n        Instance with modifications made.\n\n    \"\"\"\n    overwrite = options._OVERWRITE_ATTRIBUTES if None else overwrite\n    sections = self.keys() if None else sections\n    for section in utilities._iterify(sections):\n        with contextlib.suppress(KeyError):\n            for key, value in self.contents[section].items():\n                if (not hasattr(instance, key)\n                        or not getattr(instance, key)\n                        or overwrite):\n                    setattr(instance, key, value)\n    return instance\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.items","title":"<code>items()</code>","text":"<p>Emulates python dict <code>items</code> method.</p> <p>Returns:</p> Type Description <code>ItemsView</code> <p>A <code>tuple</code> equivalent to <code>dict.items()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def items(self) -&gt; ItemsView:\n    \"\"\"Emulates python dict `items` method.\n\n    Returns:\n        A `tuple` equivalent to `dict.items()`.\n\n    \"\"\"\n    return self.contents.items()\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.keys","title":"<code>keys()</code>","text":"<p>Returns <code>contents</code> keys as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>KeysView</code> <p>A <code>tuple</code> equivalent to <code>dict.keys()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def keys(self) -&gt; KeysView:\n    \"\"\"Returns `contents` keys as a `tuple`.\n\n    Returns:\n        A `tuple` equivalent to `dict.keys()`.\n\n    \"\"\"\n    return self.keys()\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.setdefault","title":"<code>setdefault(value)</code>","text":"<p>Sets default value to return when <code>get</code> method is used.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>default value to return when <code>get</code> is called and the <code>default</code> parameter to <code>get</code> is None.</p> required Source code in <code>src/bobbie/base.py</code> <pre><code>def setdefault(self, value: Any) -&gt; None:\n    \"\"\"Sets default value to return when `get` method is used.\n\n    Args:\n        value: default value to return when `get` is called and the\n            `default` parameter to `get` is None.\n\n    \"\"\"\n    self.default_factory = value\n    return\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of <code>contents</code>.</p> <p>This method applies <code>include</code> before <code>exclude</code> if both are passed. If <code>include</code> is None, all existing items will be added to the new subset class instance before <code>exclude</code> is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Collection[Any] | Any | None</code> <p>item(s) to include in the new <code>Dictionary</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>exclude</code> <code>Collection[Any] | Any | None</code> <p>item(s) to exclude from the new <code>Dictionary</code>. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>include</code> and <code>exclude</code> are both None.</p> <p>Returns:</p> Type Description <code>GenericDict</code> <p>A new Settings (or subclass) instance with only keys from <code>include</code> and no keys in <code>exclude</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def subset(\n    self,\n    include: Collection[Any] | Any | None = None,\n    exclude: Collection[Any] | Any | None = None) -&gt; GenericDict:\n    \"\"\"Returns a new instance with a subset of `contents`.\n\n    This method applies `include` before `exclude` if both are passed. If\n    `include` is None, all existing items will be added to the new subset\n    class instance before `exclude` is applied.\n\n    Args:\n        include: item(s) to include in the new `Dictionary`. Defaults to\n            `None`.\n        exclude: item(s) to exclude from the new `Dictionary`. Defaults to\n            `None`.\n\n    Raises:\n        ValueError: if `include` and `exclude` are both None.\n\n    Returns:\n        A new Settings (or subclass) instance with only keys from `include`\n            and no keys in `exclude`.\n\n    \"\"\"\n    if include is None and exclude is None:\n        raise ValueError('include or exclude must not be None')\n    if include is None:\n        contents = copy.deepcopy(self.contents)\n    else:\n        include = list(utilities._iterify(include))\n        contents = {k: self.contents[k] for k in include}\n    if exclude is not None:\n        exclude = list(utilities._iterify(exclude))\n        contents = {k: v for k, v in contents.items() if k not in exclude}\n    return self.__class__(contents)\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.update","title":"<code>update(item)</code>","text":"<p>Updates 'contents' using the 'add' method for key/value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>GenericDict</code> <p>a <code>dict</code>-like object to add to <code>contents</code></p> required Source code in <code>src/bobbie/base.py</code> <pre><code>def update(self, item: GenericDict) -&gt; Self:\n    \"\"\"Updates 'contents' using the 'add' method for key/value pairs.\n\n    Args:\n        item: a `dict`-like object to add to `contents`\n\n    \"\"\"\n    for key, value in item.items():\n        self.add(key, value)\n    return self\n</code></pre>"},{"location":"reference/bobbie/#bobbie.Settings.values","title":"<code>values()</code>","text":"<p>Returns <code>contents</code> values as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>ValuesView</code> <p>A <code>tuple</code> equivalent to <code>dict.values()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def values(self) -&gt; ValuesView:\n    \"\"\"Returns `contents` values as a `tuple`.\n\n    Returns:\n        A `tuple` equivalent to `dict.values()`.\n\n    \"\"\"\n    return self.contents.values()\n</code></pre>"},{"location":"reference/bobbie/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":"<p>Base classes for loading and storing configuration options.</p> Contents <p>Settings: loads and stores configuration settings with easy-to-use parser     and viewers for accessing those settings.</p> To Do <p>Add Tests for all types and <code>dict</code> methods</p>"},{"location":"reference/bobbie/base/#bobbie.base.Settings","title":"<code>Settings(contents=dict(), name=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sourcerer</code>, <code>Dictionary</code></p> <p>Loads and stores configuration settings.</p> <p>This class has an interface of an ordinary <code>dict</code>. It also adds class and instance methods that are helpful for project settings, including loading directly from numberous file types, easy injection of settings data as attributes into objects, and smart automatic type conversion from files when appropriate (depending on whether the file type supports typing).</p> <p>Currently, supported file extensions are:</p> <ul> <li><code>env</code>, <code>ini</code>, <code>json</code>, <code>py</code>, <code>toml</code>, <code>xml</code>, <code>yaml</code>, and <code>yml</code>.</li> </ul> <p>The best way to create a <code>Settings</code> instance is to call <code>Settings.create</code> and pass as the first argument a:     1) <code>pathlib</code> or <code>str</code> path to a compatible file (including a Python         module);     2) a <code>dict</code> or <code>dict</code>-like object;                                     or     3) a sequence of <code>pathlib</code> paths, <code>str</code> paths, or mappings (mixed types        in the sequence are supported).</p> <p>Any other arguments that you want passed to <code>Settings</code> (such as <code>name</code>) should be passed to the <code>parameters</code> argument. Any additional kwargs that you pass will be relayed to the constructor used by <code>bobbie</code>. For example, in Python 3.11, the builtin <code>tomllib</code> library to parse <code>toml</code> files. If you want to change the float parser to <code>decimal.Decimal</code> when loading settings from a \".toml\" file and name your <code>Settings</code> instance \"Project Settings\", you should do this:</p> <pre><code>Settings.create(\n    'configuration.toml',\n    parameters = {'name': 'Project Settings'},\n    {'parse_float': decimal.Decimal})\n</code></pre> <p>You may also instance <code>Settings</code> directly, like a normal class. However, doing so precludes the ability to relay additional keyword arguments to the constructor used by <code>bobbie</code> (<code>parse_float</code> in the above example).</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>GenericDict</code> <p>configuration options. Defaults to an empty <code>dict</code>.</p> <code>dict()</code> <code>default_factory</code> <p>default value to return or default callable to use to create the default value.</p> required <code>name</code> <code>str | None</code> <p>the <code>str</code> name of <code>Settings</code>. The top-level of a <code>Settings</code> need not have any name, but may include one for use by custom parsers. Defaults to <code>None</code>.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>defaults</code> <p>default options that should be used when a user does not provide the corresponding options in their configuration settings, but are otherwise necessary for the project. These are automatically added as the last mapping in <code>contents</code> so that all other loaded and stored options are checked first. Defaults to an empty <code>dict</code>.</p> <code>sources</code> <code>MutableMapping[type[Any], str]</code> <p><code>dict</code> with keys that are types and values are substrings of the names of methods to call when the key type is passed to the <code>create</code> method. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.sources","title":"<code>sources = {pathlib.Path: 'file', str: 'file', MutableMapping: 'dict'}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/bobbie/base/#bobbie.base.Settings._get_loader","title":"<code>_get_loader(path)</code>  <code>classmethod</code>","text":"<p>get_loader _summary</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[str, MethodType]</code> <p>description</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef _get_loader(cls, path: pathlib.Path) -&gt; tuple[str, MethodType]:\n    \"\"\"_get_loader _summary_\n\n    Args:\n        path: _description_\n\n    Returns:\n        _description_\n    \"\"\"\n    if path.is_file():\n        extension = path.suffix[1:]\n        file_type = options._FILE_EXTENSIONS[extension]\n        loader = getattr(cls, options._LOAD_METHOD(file_type))\n        return file_type, loader\n    else:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings._infer_types","title":"<code>_infer_types(contents)</code>  <code>classmethod</code>","text":"<p>Converts stored values to appropriate datatypes.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>GenericDict</code> <p>a <code>dict</code> to reparse.</p> required <p>Returns:</p> Name Type Description <code>GenericDict</code> <code>GenericDict</code> <p>with the nested values converted to the appropriate datatypes.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef _infer_types(cls, contents: GenericDict) -&gt; GenericDict:\n    \"\"\"Converts stored values to appropriate datatypes.\n\n    Args:\n        contents: a `dict` to reparse.\n\n    Returns:\n        GenericDict: with the nested values converted to\n            the appropriate datatypes.\n\n    \"\"\"\n    new_contents = {}\n    for key, value in contents.items():\n        if isinstance(value, MutableMapping):\n            inner_bundle = {\n                inner_key: options._TYPER(inner_value)\n                for inner_key, inner_value in value.items()}\n            new_contents[key] = inner_bundle\n        else:\n            new_contents[key] = options._TYPER(value)\n    return new_contents\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.add","title":"<code>add(key, value)</code>","text":"<p>Adds <code>key</code> and <code>value</code> to <code>contents</code>.</p> <p>If <code>key</code> is already a key in <code>contents</code>, the contents associated with that key are updated. If <code>key</code> doesn't exist, a new key/value pair is added to <code>contents</code>. Stored <code>dict</code>-like objects in <code>value</code> are automatically converted to <code>Settings</code> objects based on the global recursive configuration option.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>name of key to store <code>value</code>.</p> required <code>value</code> <code>GenericDict</code> <p>values to be stored.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>key</code> isn't hashable.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def add(self, key: Hashable, value: GenericDict) -&gt; None:\n    \"\"\"Adds `key` and `value` to `contents`.\n\n    If `key` is already a key in `contents`, the contents associated with\n    that key are updated. If `key` doesn't exist, a new key/value pair is\n    added to `contents`. Stored `dict`-like objects in `value` are\n    automatically converted to `Settings` objects based on the global\n    recursive configuration option.\n\n    Args:\n        key: name of key to store `value`.\n        value: values to be stored.\n\n    Raises:\n        TypeError: if `key` isn't hashable.\n\n    \"\"\"\n    try:\n        self[key].update(value)\n    except KeyError:\n        try:\n            self[key] = value\n        except TypeError as error:\n            message = 'The key must be hashable'\n            raise TypeError(message) from error\n    return\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.create","title":"<code>create(source, /, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Calls appropriate class method to create an instance.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>path to a file or <code>dict</code> with data to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>source</code> is not a <code>str</code>, <code>pathlib.Path</code>, or <code>dict</code>- like object.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@functools.singledispatchmethod\n@classmethod\ndef create(\n    cls,\n    source: Any, /,\n    parameters: GenericDict | None = None,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Calls appropriate class method to create an instance.\n\n    Args:\n        source: path to a file or `dict` with data to store in a `Settings`\n            instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        TypeError: if `source` is not a `str`, `pathlib.Path`, or `dict`-\n            like object.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    message = (\n        'The first positional argument must be a str, Path, or mapping')\n    raise TypeError(message)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.delete","title":"<code>delete(key, return_error=options._ALWAYS_RETURN_ERROR)</code>","text":"<p>Deletes <code>item</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key in <code>contents</code> to delete the key/value pair.</p> required <code>return_error</code> <code>bool</code> <p>returns error if <code>key</code> is missing. Defaults to the global setting stored in options._ALWAYS_RETURN_ERROR.</p> <code>_ALWAYS_RETURN_ERROR</code> Source code in <code>src/bobbie/base.py</code> <pre><code>def delete(\n    self,\n    key: Hashable,\n    return_error: bool = options._ALWAYS_RETURN_ERROR) -&gt; None:\n    \"\"\"Deletes `item` in `contents`.\n\n    Args:\n        key: key in `contents` to delete the key/value pair.\n        return_error: returns error if `key` is missing. Defaults to the\n            global setting stored in options._ALWAYS_RETURN_ERROR.\n\n    \"\"\"\n    try:\n        del self.contents[key]\n    except KeyError as error:\n        if return_error:\n            message = f'{key} is not found in the settings'\n            raise KeyError(message) from error\n    except TypeError as error:\n        message = 'The key must be hashable'\n        raise TypeError(message) from error\n    return\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_dict","title":"<code>from_dict(source, /, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Settings</code> instance from a <code>dict</code>-like object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>GenericDict</code> <p><code>dict</code>-like object with settings to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>any additional keyword arguments are ignored by this constructer method. They are only accepted to ensure compatibility with dispatching from the <code>create</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@create.register(MutableMapping)\n@classmethod\ndef from_dict(\n    cls,\n    source: GenericDict, /,\n    parameters: GenericDict | None = None,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a `Settings` instance from a `dict`-like object.\n\n    Args:\n        source: `dict`-like object with settings to store in a `Settings`\n            instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: any additional keyword arguments are ignored by this\n            constructer method. They are only accepted to ensure\n            compatibility with dispatching from the `create` method.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    parameters = parameters or {}\n    return cls(source, **parameters)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_env","title":"<code>from_env(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to an <code>ini</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_env(cls,source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to an `ini` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import dotenv\n    try:\n        contents = dotenv.dotenv_values(source, **kwargs)\n    except (KeyError, FileNotFoundError) as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['env']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_file","title":"<code>from_file(source, /, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Settings</code> instance from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>path to file with data to store in a <code>Settings</code> instance.</p> required <code>parameters</code> <p>additional parameters and arguments to pass to the created <code>Settings</code> instance. Defaults to None.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as file encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <code>TypeError</code> <p>if no constructor method is found for the passed file type.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>Settings</code> instance derived from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@create.register(str | pathlib.Path)\n@classmethod\ndef from_file(\n    cls,\n    source: str | pathlib.Path, /,\n    **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a `Settings` instance from a file path.\n\n    Args:\n        source: path to file with data to store in a `Settings` instance.\n        parameters: additional parameters and arguments to pass to the\n            created `Settings` instance. Defaults to None.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as file encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n        TypeError: if no constructor method is found for the passed file\n            type.\n\n    Returns:\n        A `Settings` instance derived from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    file_type, loader = cls._get_loader(path)\n    try:\n        return cls(loader(path, **kwargs))\n    except AttributeError as error:\n        message = f'Loading from {file_type} file is not supported'\n        raise TypeError(message) from error\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_ini","title":"<code>from_ini(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to an <code>ini</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_ini(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to an `ini` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import configparser\n    try:\n        contents = configparser.ConfigParser(**kwargs)\n        contents.optionxform = lambda option: option\n        contents.read(path)\n    except (KeyError, FileNotFoundError) as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['ini']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_json","title":"<code>from_json(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>json</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_json(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `json` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import json\n    try:\n        with open(pathlib.Path(path)) as settings_file:\n            contents = json.load(settings_file, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['json']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_module","title":"<code>from_module(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a Python module.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_module(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a Python module.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    try:\n        specer = importlib.util.spec_from_file_location\n        import_path = specer(path.name, path, **kwargs)\n        import_module = importlib.util.module_from_spec(import_path)\n        import_path.loader.exec_module(import_module)\n        contents = getattr(import_module, options._MODULE_SETTINGS_ATTRIBUTE)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['module']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_toml","title":"<code>from_toml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>toml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_toml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `toml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import tomllib\n    loader = tomllib.load\n    try:\n        contents = loader(path, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['toml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_xml","title":"<code>from_xml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>toml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_xml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `toml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import xmltodict\n    try:\n        with open(path) as settings_file:\n            contents = xmltodict.parse(settings_file.read(), **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['xml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.from_yaml","title":"<code>from_yaml(source, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a settings <code>dict</code> from a file path to a <code>yaml</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>path to file with data to store in a settings <code>dict</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters and arguments to pass to the constructor used by <code>bobbie</code> (such as encoding arguments).</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the <code>source</code> path does not correspond to a file.</p> <p>Returns:</p> Type Description <code>Settings</code> <p>A <code>dict</code> of settings from <code>source</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef from_yaml(cls, source: pathlib.Path | str, **kwargs:  Any) -&gt; Settings:\n    \"\"\"Creates a settings `dict` from a file path to a `yaml` file.\n\n    Args:\n        source: path to file with data to store in a settings `dict`.\n        kwargs: additional parameters and arguments to pass to the\n            constructor used by `bobbie` (such as encoding arguments).\n\n    Raises:\n        FileNotFoundError: if the `source` path does not correspond to a\n            file.\n\n    Returns:\n        A `dict` of settings from `source`.\n\n    \"\"\"\n    path = utilities._pathlibify(source)\n    import yaml\n    try:\n        with open(path) as config:\n            contents = yaml.safe_load(config, **kwargs)\n    except FileNotFoundError as error:\n        message = f'settings file {path} not found'\n        raise FileNotFoundError(message) from error\n    if options._INFER_TYPES['yaml']:\n        contents = cls._infer_types(contents)\n    return cls(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the <code>fromkeys</code> class method from a python <code>dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>GenericList</code> <p>items to be keys in a new mapping.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new mapping.</p> required <code>kwargs</code> <code>Any</code> <p>additional arguments to pass to the <code>dict.fromkeys</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GenericDict</code> <p>An instance formed from <code>keys</code> and <code>value</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>@classmethod\ndef fromkeys(\n    cls,\n    keys: GenericList,\n    value: Any,\n    **kwargs: Any) -&gt; GenericDict:\n    \"\"\"Emulates the `fromkeys` class method from a python `dict`.\n\n    Args:\n        keys: items to be keys in a new mapping.\n        value: the value to use for all values in a new mapping.\n        kwargs: additional arguments to pass to the `dict.fromkeys` method.\n\n    Returns:\n        An instance formed from `keys` and `value`.\n\n    \"\"\"\n    return cls(dict.fromkeys(keys, value), **kwargs)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns value in <code>contents</code> or default options.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key for value in <code>contents</code>.</p> required <code>default</code> <code>Any | None</code> <p>default value to return if <code>key</code> is not found in <code>contents</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>key</code> is not in <code>contents</code> and <code>default</code> and the <code>default_factory</code> attribute are both <code>None</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Value matching key in <code>contents</code> or a default value.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def get(self, key: Hashable, default: Any | None = None) -&gt; Any:\n    \"\"\"Returns value in `contents` or default options.\n\n    Args:\n        key: key for value in `contents`.\n        default: default value to return if `key` is not found in\n            `contents`.\n\n    Raises:\n        KeyError: if `key` is not in `contents` and `default` and the\n            `default_factory` attribute are both `None`.\n\n    Returns:\n        Value matching key in `contents` or a default value.\n\n    \"\"\"\n    try:\n        return self[key]\n    except (KeyError, TypeError) as error:\n        if default is not None:\n            return default\n        if self.default_factory is None:\n            raise KeyError(f'{key} is not in the Settings') from error\n        try:\n            return self.default_factory()\n        except TypeError:\n            return self.default_factory\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.inject","title":"<code>inject(instance, sections=None, overwrite=None)</code>","text":"<p>Injects appropriate items into <code>instance</code> from <code>contents</code>.</p> <p>By default, if <code>instance</code> has a <code>name</code> attribute, this method will add any settings in a section matching that <code>name</code> to <code>instance</code> as attributes.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>class instance to be modified.</p> required <code>sections</code> <code>Sequence[str] | str | None</code> <p>other section(s) in <code>contents</code> to add to <code>instance</code>. Defaults to None (which will result in all sections being injected).</p> <code>None</code> <code>overwrite</code> <code>bool | None</code> <p>whether to overwrite a local attribute in <code>instance</code> if there are existing values stored in that attribute. Defaults to None (which will result in the default value in <code>_OVERWRITE_ATTRIBUTES</code> will be used).</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Instance with modifications made.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def inject(\n    self,\n    instance: object,\n    sections: Sequence[str] | str | None = None,\n    overwrite: bool | None = None) -&gt; object:\n    \"\"\"Injects appropriate items into `instance` from `contents`.\n\n    By default, if `instance` has a `name` attribute, this method will add\n    any settings in a section matching that `name` to `instance` as\n    attributes.\n\n    Args:\n        instance: class instance to be modified.\n        sections: other section(s) in `contents` to add to `instance`.\n            Defaults to None (which will result in all sections being\n            injected).\n        overwrite: whether to overwrite a local attribute in `instance` if\n            there are existing values stored in that attribute. Defaults to\n            None (which will result in the default value in\n            `_OVERWRITE_ATTRIBUTES` will be used).\n\n    Returns:\n        Instance with modifications made.\n\n    \"\"\"\n    overwrite = options._OVERWRITE_ATTRIBUTES if None else overwrite\n    sections = self.keys() if None else sections\n    for section in utilities._iterify(sections):\n        with contextlib.suppress(KeyError):\n            for key, value in self.contents[section].items():\n                if (not hasattr(instance, key)\n                        or not getattr(instance, key)\n                        or overwrite):\n                    setattr(instance, key, value)\n    return instance\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.items","title":"<code>items()</code>","text":"<p>Emulates python dict <code>items</code> method.</p> <p>Returns:</p> Type Description <code>ItemsView</code> <p>A <code>tuple</code> equivalent to <code>dict.items()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def items(self) -&gt; ItemsView:\n    \"\"\"Emulates python dict `items` method.\n\n    Returns:\n        A `tuple` equivalent to `dict.items()`.\n\n    \"\"\"\n    return self.contents.items()\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.keys","title":"<code>keys()</code>","text":"<p>Returns <code>contents</code> keys as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>KeysView</code> <p>A <code>tuple</code> equivalent to <code>dict.keys()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def keys(self) -&gt; KeysView:\n    \"\"\"Returns `contents` keys as a `tuple`.\n\n    Returns:\n        A `tuple` equivalent to `dict.keys()`.\n\n    \"\"\"\n    return self.keys()\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.setdefault","title":"<code>setdefault(value)</code>","text":"<p>Sets default value to return when <code>get</code> method is used.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>default value to return when <code>get</code> is called and the <code>default</code> parameter to <code>get</code> is None.</p> required Source code in <code>src/bobbie/base.py</code> <pre><code>def setdefault(self, value: Any) -&gt; None:\n    \"\"\"Sets default value to return when `get` method is used.\n\n    Args:\n        value: default value to return when `get` is called and the\n            `default` parameter to `get` is None.\n\n    \"\"\"\n    self.default_factory = value\n    return\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of <code>contents</code>.</p> <p>This method applies <code>include</code> before <code>exclude</code> if both are passed. If <code>include</code> is None, all existing items will be added to the new subset class instance before <code>exclude</code> is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Collection[Any] | Any | None</code> <p>item(s) to include in the new <code>Dictionary</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>exclude</code> <code>Collection[Any] | Any | None</code> <p>item(s) to exclude from the new <code>Dictionary</code>. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>include</code> and <code>exclude</code> are both None.</p> <p>Returns:</p> Type Description <code>GenericDict</code> <p>A new Settings (or subclass) instance with only keys from <code>include</code> and no keys in <code>exclude</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def subset(\n    self,\n    include: Collection[Any] | Any | None = None,\n    exclude: Collection[Any] | Any | None = None) -&gt; GenericDict:\n    \"\"\"Returns a new instance with a subset of `contents`.\n\n    This method applies `include` before `exclude` if both are passed. If\n    `include` is None, all existing items will be added to the new subset\n    class instance before `exclude` is applied.\n\n    Args:\n        include: item(s) to include in the new `Dictionary`. Defaults to\n            `None`.\n        exclude: item(s) to exclude from the new `Dictionary`. Defaults to\n            `None`.\n\n    Raises:\n        ValueError: if `include` and `exclude` are both None.\n\n    Returns:\n        A new Settings (or subclass) instance with only keys from `include`\n            and no keys in `exclude`.\n\n    \"\"\"\n    if include is None and exclude is None:\n        raise ValueError('include or exclude must not be None')\n    if include is None:\n        contents = copy.deepcopy(self.contents)\n    else:\n        include = list(utilities._iterify(include))\n        contents = {k: self.contents[k] for k in include}\n    if exclude is not None:\n        exclude = list(utilities._iterify(exclude))\n        contents = {k: v for k, v in contents.items() if k not in exclude}\n    return self.__class__(contents)\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.update","title":"<code>update(item)</code>","text":"<p>Updates 'contents' using the 'add' method for key/value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>GenericDict</code> <p>a <code>dict</code>-like object to add to <code>contents</code></p> required Source code in <code>src/bobbie/base.py</code> <pre><code>def update(self, item: GenericDict) -&gt; Self:\n    \"\"\"Updates 'contents' using the 'add' method for key/value pairs.\n\n    Args:\n        item: a `dict`-like object to add to `contents`\n\n    \"\"\"\n    for key, value in item.items():\n        self.add(key, value)\n    return self\n</code></pre>"},{"location":"reference/bobbie/base/#bobbie.base.Settings.values","title":"<code>values()</code>","text":"<p>Returns <code>contents</code> values as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>ValuesView</code> <p>A <code>tuple</code> equivalent to <code>dict.values()</code>.</p> Source code in <code>src/bobbie/base.py</code> <pre><code>def values(self) -&gt; ValuesView:\n    \"\"\"Returns `contents` values as a `tuple`.\n\n    Returns:\n        A `tuple` equivalent to `dict.values()`.\n\n    \"\"\"\n    return self.contents.values()\n</code></pre>"},{"location":"reference/bobbie/options/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> options","text":"<p>Settings, constants, and global types for <code>bobbie</code>.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/bobbie/options/#bobbie.options._TYPER","title":"<code>_TYPER = utilities._typify</code>  <code>module-attribute</code>","text":"<p>Missing Argument Sentinel Class and Instance</p>"},{"location":"reference/bobbie/options/#bobbie.options._MISSING_VALUE","title":"<code>_MISSING_VALUE()</code>  <code>dataclass</code>","text":"<p>Sentinel object for a missing data or parameter.</p> <p>This follows the same pattern as the <code>_MISSING_TYPE</code> class in the builtin dataclasses library. https://github.com/python/cpython/blob/3.10/Lib/dataclasses.py#L182-L186</p> <p>Because None is sometimes a valid argument or data option, this class provides an alternative that does not create the confusion that a default of None can sometimes lead to.</p>"},{"location":"reference/bobbie/utilities/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utilities","text":"<p>Shared tools.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/bobbie/utilities/#bobbie.utilities._iterify","title":"<code>_iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate str types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable</p> required <p>Returns:</p> Type Description <code>Iterable</code> <p>Iterable of <code>item</code>. A <code>str</code> type will be stored as a single item in an Iterable wrapper.</p> Source code in <code>src/bobbie/utilities.py</code> <pre><code>def _iterify(item: Any) -&gt; Iterable:\n    \"\"\"Returns `item` as an iterable, but does not iterate str types.\n\n    Args:\n        item: item to turn into an iterable\n\n    Returns:\n        Iterable of `item`. A `str` type will be stored as a single item in an\n            Iterable wrapper.\n\n    \"\"\"\n    if item is None:\n        return iter(())\n    elif isinstance(item, str | bytes):\n        return iter([item])\n    else:\n        try:\n            return iter(item)\n        except TypeError:\n            return iter((item,))\n</code></pre>"},{"location":"reference/bobbie/utilities/#bobbie.utilities._pathlibify","title":"<code>_pathlibify(item)</code>","text":"<p>Converts string <code>path</code> to pathlib.Path object.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>either a string of a path or a pathlib.Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path object.</p> Source code in <code>src/bobbie/utilities.py</code> <pre><code>def _pathlibify(item: str | pathlib.Path) -&gt; pathlib.Path:\n    \"\"\"Converts string `path` to pathlib.Path object.\n\n    Args:\n        item: either a string of a path or a pathlib.Path object.\n\n    Raises:\n        TypeError if `path` is neither a str or pathlib.Path type.\n\n    Returns:\n        pathlib.Path object.\n\n    \"\"\"\n    if isinstance(item, str):\n        return pathlib.Path(item)\n    elif isinstance(item, pathlib.Path):\n        return item\n    else:\n        raise TypeError('item must be str or pathlib.Path type')\n</code></pre>"},{"location":"reference/bobbie/utilities/#bobbie.utilities._typify","title":"<code>_typify(item)</code>","text":"<p>Converts stings to appropriate, supported datatypes.</p> <p>The method converts strings to list (if ', ' is present), int, float, or bool datatypes based upon the content of the string. If no alternative datatype is found, the item is returned in its original form.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>string to be converted to appropriate datatype.</p> required <p>Returns:</p> Type Description <code>list[Any] | int | float | bool | str</code> <p>Converted item.</p> Source code in <code>src/bobbie/utilities.py</code> <pre><code>def _typify(item: str) -&gt; list[Any] | int | float | bool | str:\n    \"\"\"Converts stings to appropriate, supported datatypes.\n\n    The method converts strings to list (if ', ' is present), int, float,\n    or bool datatypes based upon the content of the string. If no\n    alternative datatype is found, the item is returned in its original\n    form.\n\n    Args:\n        item: string to be converted to appropriate datatype.\n\n    Returns:\n        Converted item.\n\n    \"\"\"\n    if not isinstance(item, str):\n        return item\n    try:\n        return int(item)\n    except ValueError:\n        try:\n            return float(item)\n        except ValueError:\n            if item.lower() in {'true', 'yes'}:\n                return True\n            elif item.lower() in {'false', 'no'}:\n                return False\n            elif ', ' in item:\n                item = item.split(', ')\n                return [_typify(i) for i in item]\n            else:\n                return item\n</code></pre>"}]}